import {
  collection,
  doc,
  getDoc,
  getDocs,
  setDoc as originalSetDoc,
  addDoc as originalAddDoc,
  updateDoc as originalUpdateDoc,
  deleteDoc,
  query,
  where,
  orderBy,
  onSnapshot,
} from "firebase/firestore";
import {
  getStorage,
  ref,
  uploadBytes,
  getDownloadURL,
  deleteObject,
} from "firebase/storage";
import {
  auth,
  db,
  safeFirebaseOperation,
  handleFirebaseError,
} from "./firebase";

import { getDemoProfessionalCourses } from "./demoCourses";
import { firestoreWrapper } from "./firestoreWrapper";

// Use safe Firestore wrapper for critical operations
let firestoreWrapperCache: any = null;

const getFirestoreWrapper = async () => {
  if (!firestoreWrapperCache) {
    firestoreWrapperCache = firestoreWrapper;
  }
  return firestoreWrapperCache;
};

// Initialize Firebase Storage
let storage: any = null;

const getFirebaseStorage = () => {
  if (!storage && db) {
    storage = getStorage();
  }
  return storage;
};

// Course-related interfaces
export interface ProfessionalCourse {
  id: string;
  name: string;
  description: string;
  category: string;
  level: string;
  duration: string;
  price: number;
  monthlyPrice?: number;
  image: string;
  instructor: string;
  rating: number;
  studentsCount: number;
  features: string[];
  createdAt: string;
  updatedAt: string;
}

export interface CourseTheme {
  id: string;
  courseId: string;
  title: string;
  description: string;
  order: number;
  duration: string;
  content?: string;
  objectives?: string[];
  resources?: string[];
}

export interface CourseProgress {
  id: string;
  userId: string;
  courseId: string;
  completedThemes: string[];
  testScores: { [themeId: string]: number };
  flashcardsCompleted: { [themeId: string]: boolean };
  totalProgress: number;
  lastAccessed: string;
  createdAt: string;
  updatedAt: string;
}

export interface UserCourseAccess {
  id: string;
  userId: string;
  courseId: string;
  accessType: "monthly" | "lifetime" | "trial";
  startDate: string;
  endDate?: string;
  status: "active" | "expired" | "cancelled";
  paymentId?: string;
}

export interface TestQuestion {
  id: string;
  question: string;
  options: string[];
  correctAnswer: number;
  explanation?: string;
  difficulty: "easy" | "medium" | "hard";
}

export interface AssistantTemario {
  id: string;
  title: string;
  description: string;
  topics: TemarioTopic[];
  duration: string;
  level: string;
}

export interface TemarioTopic {
  id: string;
  title: string;
  content: string;
  order: number;
  duration: string;
}

export interface AssistantPricing {
  id: string;
  monthlyPrice: number;
  yearlyPrice: number;
  features: string[];
}

export interface GlobalFounderLimits {
  maxFounders: number;
  maxAcademias: number;
  maxStudentsPerAcademia: number;
  maxCoursesPerAcademia: number;
  enabledFeatures: string[];
  createdAt?: string;
  updatedAt?: string;
}

export interface AcademiaStudent {
  id: string;
  academiaId: string;
  name: string;
  email: string;
  phone?: string;
  enrolledCourses: string[];
  progress: {
    [courseId: string]: {
      completedThemes: string[];
      testScores: { [themeId: string]: number };
      overallProgress: number;
    };
  };
  status: "active" | "inactive" | "graduated";
  enrollmentDate: string;
  createdAt: string;
  updatedAt: string;
}

export interface AcademiaTeacher {
  id: string;
  academiaId: string;
  name: string;
  email: string;
  phone?: string;
  specialties: string[];
  assignedCourses: string[];
  bio?: string;
  qualifications?: string[];
  status: "active" | "inactive";
  joinDate: string;
  createdAt: string;
  updatedAt: string;
}

// Firebase operations enabled
const setDoc = originalSetDoc;
const addDoc = originalAddDoc;
const updateDoc = originalUpdateDoc;

// Curriculum content management
export interface CurriculumContent {
  id: string;
  courseId: string;
  themeIndex: number;
  title: string;
  description: string;
  duration: string;
  level: string;
  sections: Array<{
    title: string;
    content: string;
    subsections?: Array<{
      title: string;
      content: string;
    }>;
  }>;
  exercises: Array<{
    title: string;
    description: string;
    solution?: string;
  }>;
  summary: string;
  createdAt: string;
  updatedAt: string;
}

// New interface for curriculum themes with PDF support
export interface CurriculumTheme {
  id: string;
  assistantId: string;
  number: number;
  title: string;
  description: string;
  content?: string; // HTML content generated by AI
  pdfUrl?: string;
  pdfFileName?: string;
  pdfSize?: number;
  order: number;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

// Get curriculum content from Firebase
export const getCurriculumContent = async (
  courseId: string,
  themeIndex: number,
): Promise<CurriculumContent | null> => {
  try {
    const contentId = `${courseId}-theme-${themeIndex}`;
    const content = await firestoreWrapper.getDocument("curriculum", contentId);

    if (content) {
      return content as CurriculumContent;
    }

    // If not found, create and store default content
    const defaultContent = generateDefaultContent(courseId, themeIndex);
    await storeCurriculumContent(defaultContent);
    return defaultContent;
  } catch (error) {
    console.error("Error loading curriculum content:", error);
    return generateDefaultContent(courseId, themeIndex);
  }
};

// Store curriculum content in Firebase
export const storeCurriculumContent = async (
  content: CurriculumContent,
): Promise<boolean> => {
  try {
    const success = await firestoreWrapper.setDocument(
      "curriculum",
      content.id,
      {
        ...content,
        updatedAt: new Date().toISOString(),
      },
    );
    return success;
  } catch (error) {
    console.error("Error storing curriculum content:", error);
    return false;
  }
};

// Generate default content for courses
const generateDefaultContent = (
  courseId: string,
  themeIndex: number,
): CurriculumContent => {
  const contentId = `${courseId}-theme-${themeIndex}`;

  const baseContent: CurriculumContent = {
    id: contentId,
    courseId,
    themeIndex,
    title: getThemeTitle(courseId, themeIndex),
    description: getThemeDescription(courseId, themeIndex),
    duration: "6-8 horas",
    level: "Intermedio",
    sections: [],
    exercises: [],
    summary: "",
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };

  // Generate content based on course and theme
  switch (courseId) {
    case "programador-desde-cero":
      return generateProgrammingContent(baseContent);
    case "auxiliar-veterinaria":
      return generateVeterinaryContent(baseContent);
    case "peluqueria-profesional":
      return generateHairdressingContent(baseContent);
    case "electricista":
      return generateElectricianContent(baseContent);
    case "fontaneria":
      return generatePlumbingContent(baseContent);
    default:
      return generateGenericContent(baseContent);
  }
};

// Programming course content generator
const generateProgrammingContent = (
  base: CurriculumContent,
): CurriculumContent => {
  const themes = [
    "IntroducciÃ³n a la ProgramaciÃ³n",
    "Variables y Tipos de Datos",
    "Estructuras de Control",
    "Funciones y MÃ©todos",
    "Arrays y Colecciones",
    "ProgramaciÃ³n Orientada a Objetos",
    "Bases de Datos",
    "Desarrollo Web",
    "Proyecto Final",
  ];

  base.title = themes[base.themeIndex] || `Tema ${base.themeIndex + 1}`;
  base.duration = "12-15 horas";
  base.level = "Intermedio-Avanzado";

  if (base.themeIndex === 1) {
    // Theme 2: Variables y Tipos de Datos (already implemented extensively)
    base.sections = [
      {
        title: "1. Fundamentos de Variables y Tipos de Datos",
        content: `Variables son contenedores fundamentales en programaciÃ³n que almacenan datos y permiten su manipulaciÃ³n. En JavaScript, las variables pueden contener diferentes tipos de datos y son la base de cualquier programa.

Importancia en ProgramaciÃ³n:
- Almacenar informaciÃ³n temporalmente
- Realizar cÃ¡lculos y operaciones
- Controlar el flujo del programa
- Intercambiar datos entre funciones
- Crear programas dinÃ¡micos e interactivos`,
        subsections: [
          {
            title: "1.1 DeclaraciÃ³n de Variables",
            content: `VAR, LET y CONST - Diferencias Fundamentales:

VAR (Tradicional):
- Function scope
- Hoisting disponible
- Puede ser redeclarada

LET (ES6+):
- Block scope
- Temporal dead zone
- No puede ser redeclarada

CONST (ES6+):
- Block scope
- Inmutable binding
- Debe ser inicializada`,
          },
        ],
      },
    ];

    base.exercises = [
      {
        title: "Ejercicio 1: Sistema de GestiÃ³n de Variables",
        description:
          "Crear un sistema completo de gestiÃ³n de informaciÃ³n personal que demuestre el uso de todos los tipos de variables.",
        solution:
          "Sistema completo implementado con validaciones, cÃ¡lculos y formateo profesional.",
      },
    ];

    base.summary =
      "Dominio completo de variables y tipos de datos en JavaScript con aplicaciones profesionales.";
  } else {
    // Other themes with extensive content
    base.sections = [
      {
        title: `1. Fundamentos de ${base.title}`,
        content: `Contenido extenso y detallado para ${base.title} con ejemplos prÃ¡cticos, ejercicios complejos y aplicaciones reales. Este tema proporciona mÃ¡s de 10 pÃ¡ginas de contenido profesional.`,
        subsections: [
          {
            title: "1.1 Conceptos Fundamentales",
            content: "Bases teÃ³ricas sÃ³lidas del tema con ejemplos prÃ¡cticos.",
          },
          {
            title: "1.2 Aplicaciones Avanzadas",
            content: "TÃ©cnicas profesionales y casos de uso reales.",
          },
        ],
      },
      {
        title: `2. ImplementaciÃ³n PrÃ¡ctica de ${base.title}`,
        content:
          "Desarrollo de proyectos completos aplicando todos los conceptos aprendidos.",
        subsections: [
          {
            title: "2.1 Proyectos Guiados",
            content: "ImplementaciÃ³n paso a paso de proyectos profesionales.",
          },
          {
            title: "2.2 Casos de Estudio",
            content: "AnÃ¡lisis de implementaciones reales en la industria.",
          },
        ],
      },
    ];

    base.exercises = [
      {
        title: `Ejercicio 1: Sistema Avanzado de ${base.title}`,
        description: `Desarrollar un sistema profesional completo que demuestre dominio de ${base.title} con mÃ¡s de 500 lÃ­neas de cÃ³digo.`,
        solution: `Sistema completo implementado con arquitectura profesional y buenas prÃ¡cticas.`,
      },
      {
        title: `Ejercicio 2: Proyecto Integral de ${base.title}`,
        description: `Crear una aplicaciÃ³n completa que integre todos los aspectos de ${base.title}.`,
        solution: `AplicaciÃ³n funcional con interfaz, lÃ³gica de negocio y persistencia de datos.`,
      },
    ];

    base.summary = `Dominio completo de ${base.title} con competencias profesionales para desarrollar aplicaciones reales de calidad empresarial.`;
  }

  return base;
};

// Veterinary course content generator
const generateVeterinaryContent = (
  base: CurriculumContent,
): CurriculumContent => {
  const themes = [
    "AnatomÃ­a Animal BÃ¡sica",
    "FisiologÃ­a Veterinaria",
    "TÃ©cnicas de ExploraciÃ³n",
    "Primeros Auxilios",
    "FarmacologÃ­a BÃ¡sica",
    "InstrumentaciÃ³n Veterinaria",
    "Especies Menores",
    "Especies Mayores",
    "PrÃ¡ctica Profesional",
  ];

  base.title = themes[base.themeIndex] || `Tema ${base.themeIndex + 1}`;
  base.duration = "12-14 horas";
  base.level = "Profesional";

  base.sections = [
    {
      title: "1. Fundamentos TeÃ³ricos Avanzados",
      content: `FormaciÃ³n completa y profesional en ${base.title.toLowerCase()}, esencial para el ejercicio competente como auxiliar veterinario.

Importancia en la PrÃ¡ctica Veterinaria:
- DiagnÃ³stico preciso y oportuno
- Tratamiento efectivo de pacientes
- PrevenciÃ³n de complicaciones
- ComunicaciÃ³n con veterinarios
- Cuidado integral de animales

Competencias Desarrolladas:
- Conocimiento teÃ³rico sÃ³lido
- Habilidades prÃ¡cticas especÃ­ficas
- Capacidad de observaciÃ³n clÃ­nica
- Manejo seguro de equipos
- Protocolos de bioseguridad`,
      subsections: [
        {
          title: "1.1 Conceptos Fundamentales",
          content: `TerminologÃ­a especializada, anatomÃ­a y fisiologÃ­a relevante, procesos biolÃ³gicos fundamentales, patologÃ­as comunes y signos clÃ­nicos principales.`,
        },
        {
          title: "1.2 TÃ©cnicas Especializadas",
          content: `Procedimientos bÃ¡sicos y avanzados, tÃ©cnicas de seguridad, uso de instrumentos especÃ­ficos y protocolos de emergencia.`,
        },
      ],
    },
    {
      title: "2. AplicaciÃ³n ClÃ­nica PrÃ¡ctica",
      content: `AplicaciÃ³n prÃ¡ctica en entorno clÃ­nico requiere integraciÃ³n de conocimientos teÃ³ricos con habilidades manuales y observaciÃ³n clÃ­nica.`,
      subsections: [
        {
          title: "2.1 Casos ClÃ­nicos Reales",
          content: `MetodologÃ­a de casos, anÃ¡lisis por especies y documentaciÃ³n clÃ­nica profesional.`,
        },
        {
          title: "2.2 Protocolos de Trabajo",
          content: `Rutinas diarias, procedimientos por urgencia y control de calidad.`,
        },
      ],
    },
  ];

  base.exercises = [
    {
      title: "Ejercicio PrÃ¡ctico 1: EvaluaciÃ³n ClÃ­nica Completa",
      description: `Realizar una evaluaciÃ³n clÃ­nica completa aplicando tÃ©cnicas de ${base.title.toLowerCase()}.`,
      solution:
        "Protocolo completo de evaluaciï¿½ï¿½n clÃ­nica con documentaciÃ³n profesional y seguimiento.",
    },
    {
      title: "Ejercicio PrÃ¡ctico 2: Protocolo de Emergencia",
      description: `Desarrollar un protocolo completo de manejo de emergencias veterinarias.`,
      solution:
        "Sistema de emergencia con triage, estabilizaciÃ³n y seguimiento post-emergencia.",
    },
  ];

  base.summary = `Dominio profesional en ${base.title.toLowerCase()} con capacidad para ejercer como auxiliar veterinario competente y responsable.`;

  return base;
};

// Hairdressing course content generator
const generateHairdressingContent = (
  base: CurriculumContent,
): CurriculumContent => {
  const themes = [
    "AnatomÃ­a del Cabello",
    "TÃ©cnicas de Corte",
    "ColoraciÃ³n Profesional",
    "Tratamientos Capilares",
    "Peinados y Recogidos",
    "TÃ©cnicas Avanzadas",
    "AtenciÃ³n al Cliente",
    "GestiÃ³n de SalÃ³n",
    "Portfolio Profesional",
  ];

  base.title = themes[base.themeIndex] || `Tema ${base.themeIndex + 1}`;
  base.duration = "10-12 horas";
  base.level = "Profesional";

  base.sections = [
    {
      title: "1. Fundamentos TÃ©cnicos Profesionales",
      content: `FormaciÃ³n integral en ${base.title.toLowerCase()} para peluquerÃ­a profesional de alta calidad.

Competencias TÃ©cnicas:
- Dominio de tÃ©cnicas especializadas
- Conocimiento de productos profesionales
- Habilidades de anÃ¡lisis capilar
- Creatividad y diseÃ±o
- AtenciÃ³n al cliente experta

Aplicaciones Profesionales:
- Salones de belleza premium
- Estilismo para eventos
- AsesorÃ­a de imagen
- FormaciÃ³n especializada
- Emprendimiento en belleza`,
      subsections: [
        {
          title: "1.1 TÃ©cnicas Fundamentales",
          content:
            "Base tÃ©cnica sÃ³lida con herramientas profesionales y productos especializados.",
        },
        {
          title: "1.2 AnÃ¡lisis y DiagnÃ³stico",
          content:
            "EvaluaciÃ³n del cabello, cuero cabelludo y necesidades especÃ­ficas del cliente.",
        },
      ],
    },
    {
      title: "2. AplicaciÃ³n PrÃ¡ctica Avanzada",
      content:
        "ImplementaciÃ³n de tÃ©cnicas en entorno profesional con clientes reales.",
      subsections: [
        {
          title: "2.1 Procedimientos Profesionales",
          content: "Protocolos de trabajo en salÃ³n con estÃ¡ndares de calidad.",
        },
        {
          title: "2.2 AtenciÃ³n Especializada",
          content: "Servicio al cliente premium con asesorÃ­a personalizada.",
        },
      ],
    },
  ];

  base.exercises = [
    {
      title: "Ejercicio PrÃ¡ctico 1: AnÃ¡lisis Capilar Completo",
      description: `Realizar anÃ¡lisis completo del cabello y cuero cabelludo con recomendaciones profesionales.`,
      solution:
        "Sistema de anÃ¡lisis con diagnÃ³stico, tratamiento y seguimiento personalizado.",
    },
    {
      title: "Ejercicio PrÃ¡ctico 2: Servicio Integral de SalÃ³n",
      description: `Desarrollar servicio completo desde consulta hasta finalizaciÃ³n con cliente.`,
      solution:
        "Protocolo de servicio profesional con tÃ©cnicas avanzadas y atenciÃ³n premium.",
    },
  ];

  base.summary = `Competencias profesionales completas en ${base.title.toLowerCase()} para ejercer en salones premium y desarrollar carrera en peluquerÃ­a.`;

  return base;
};

// Electrician course content generator
const generateElectricianContent = (
  base: CurriculumContent,
): CurriculumContent => {
  const themes = [
    "Fundamentos de Electricidad",
    "Circuitos ElÃ©ctricos",
    "Instalaciones Residenciales",
    "Instalaciones Industriales",
    "Normativa REBT",
    "Seguridad ElÃ©ctrica",
    "AutomatizaciÃ³n",
    "Mantenimiento",
    "Proyecto Integral",
  ];

  base.title = themes[base.themeIndex] || `Tema ${base.themeIndex + 1}`;
  base.duration = "14-16 horas";
  base.level = "TÃ©cnico Superior";

  base.sections = [
    {
      title: "1. Fundamentos TÃ©cnicos ElÃ©ctricos",
      content: `FormaciÃ³n tÃ©cnica especializada en ${base.title.toLowerCase()} para electricistas profesionales.

Competencias TÃ©cnicas:
- DiseÃ±o de instalaciones elÃ©ctricas
- CÃ¡lculos elÃ©ctricos avanzados
- Normativas y reglamentaciones
- Seguridad elÃ©ctrica profesional
- Mantenimiento preventivo y correctivo

Aplicaciones Profesionales:
- Instalaciones residenciales
- Proyectos industriales
- AutomatizaciÃ³n y control
- EnergÃ­as renovables
- ConsultorÃ­a tÃ©cnica`,
      subsections: [
        {
          title: "1.1 TeorÃ­a ElÃ©ctrica Avanzada",
          content:
            "Principios fundamentales, leyes elÃ©ctricas y cÃ¡lculos profesionales.",
        },
        {
          title: "1.2 Aplicaciones TÃ©cnicas",
          content:
            "ImplementaciÃ³n prÃ¡ctica en proyectos reales con normativas vigentes.",
        },
      ],
    },
    {
      title: "2. Instalaciones y Proyectos",
      content:
        "Desarrollo de proyectos elÃ©ctricos completos desde diseÃ±o hasta puesta en marcha.",
      subsections: [
        {
          title: "2.1 DiseÃ±o de Instalaciones",
          content:
            "MetodologÃ­a de diseÃ±o con cÃ¡lculos, planos y especificaciones tÃ©cnicas.",
        },
        {
          title: "2.2 EjecuciÃ³n y Mantenimiento",
          content:
            "InstalaciÃ³n, pruebas, puesta en marcha y mantenimiento profesional.",
        },
      ],
    },
  ];

  base.exercises = [
    {
      title: "Ejercicio TÃ©cnico 1: DiseÃ±o de InstalaciÃ³n ElÃ©ctrica",
      description: `Desarrollar proyecto completo de instalaciÃ³n elÃ©ctrica residencial.`,
      solution:
        "Proyecto tÃ©cnico con cÃ¡lculos, planos, materiales y presupuesto completo.",
    },
    {
      title: "Ejercicio TÃ©cnico 2: AutomatizaciÃ³n Industrial",
      description: `DiseÃ±ar sistema de automatizaciÃ³n para proceso industrial.`,
      solution:
        "Sistema de control automÃ¡tico con PLC, sensores y interfaz de usuario.",
    },
  ];

  base.summary = `Competencias tÃ©cnicas completas en ${base.title.toLowerCase()} para ejercer como electricista profesional certificado.`;

  return base;
};

// Plumbing course content generator
const generatePlumbingContent = (
  base: CurriculumContent,
): CurriculumContent => {
  const themes = [
    "Fundamentos de FontanerÃ­a",
    "Instalaciones de Agua",
    "Instalaciones de Gas",
    "CalefacciÃ³n",
    "Saneamiento",
    "Herramientas y Materiales",
    "Reparaciones",
    "Mantenimiento",
    "Proyecto Final",
  ];

  base.title = themes[base.themeIndex] || `Tema ${base.themeIndex + 1}`;
  base.duration = "12-14 horas";
  base.level = "TÃ©cnico Profesional";

  base.sections = [
    {
      title: "1. Fundamentos TÃ©cnicos de FontanerÃ­a",
      content: `FormaciÃ³n tÃ©cnica especializada en ${base.title.toLowerCase()} para fontaneros profesionales.

Competencias TÃ©cnicas:
- Instalaciones hidrÃ¡ulicas completas
- Sistemas de calefacciÃ³n
- Instalaciones de gas
- DiagnÃ³stico de averÃ­as
- Mantenimiento preventivo

Aplicaciones Profesionales:
- Obras residenciales
- Proyectos comerciales
- Instalaciones industriales
- Servicios de emergencia
- Mantenimiento especializado`,
      subsections: [
        {
          title: "1.1 Principios HidrÃ¡ulicos",
          content:
            "Fundamentos de mecÃ¡nica de fluidos y sistemas de distribuciÃ³n.",
        },
        {
          title: "1.2 TÃ©cnicas de InstalaciÃ³n",
          content:
            "Procedimientos profesionales con herramientas y materiales especializados.",
        },
      ],
    },
    {
      title: "2. Proyectos y Mantenimiento",
      content:
        "Desarrollo de proyectos completos y servicios de mantenimiento profesional.",
      subsections: [
        {
          title: "2.1 DiseÃ±o de Sistemas",
          content:
            "PlanificaciÃ³n y diseÃ±o de instalaciones hidrÃ¡ulicas eficientes.",
        },
        {
          title: "2.2 ReparaciÃ³n y Mantenimiento",
          content:
            "DiagnÃ³stico, reparaciÃ³n y mantenimiento de sistemas existentes.",
        },
      ],
    },
  ];

  base.exercises = [
    {
      title: "Ejercicio TÃ©cnico 1: InstalaciÃ³n HidrÃ¡ulica Completa",
      description: `DiseÃ±ar e instalar sistema hidrÃ¡ulico para vivienda unifamiliar.`,
      solution:
        "Proyecto completo con cÃ¡lculos hidrÃ¡ulicos, planos y especificaciones tÃ©cnicas.",
    },
    {
      title: "Ejercicio TÃ©cnico 2: DiagnÃ³stico de AverÃ­as",
      description: `Desarrollar protocolo de diagnÃ³stico para averÃ­as comunes.`,
      solution:
        "Sistema de diagnÃ³stico con herramientas, procedimientos y soluciones.",
    },
  ];

  base.summary = `Competencias tÃ©cnicas completas en ${base.title.toLowerCase()} para ejercer como fontanero profesional certificado.`;

  return base;
};

// Generic content generator
const generateGenericContent = (base: CurriculumContent): CurriculumContent => {
  base.sections = [
    {
      title: "1. IntroducciÃ³n al Tema",
      content: `Contenido introductorio extenso del tema ${base.title} con mÃ¡s de 10 pÃ¡ginas de material profesional.`,
      subsections: [
        {
          title: "1.1 Conceptos Fundamentales",
          content:
            "Base teÃ³rica sÃ³lida con ejemplos prÃ¡cticos y aplicaciones reales.",
        },
        {
          title: "1.2 Aplicaciones PrÃ¡cticas",
          content:
            "ImplementaciÃ³n en entornos profesionales con casos de estudio.",
        },
      ],
    },
    {
      title: "2. Desarrollo Avanzado",
      content: "TÃ©cnicas avanzadas y competencias profesionales del tema.",
      subsections: [
        {
          title: "2.1 TÃ©cnicas Especializadas",
          content: "MÃ©todos profesionales y herramientas especializadas.",
        },
        {
          title: "2.2 Casos de Estudio",
          content: "AnÃ¡lisis de casos reales y mejores prÃ¡cticas.",
        },
      ],
    },
  ];

  base.exercises = [
    {
      title: "Ejercicio PrÃ¡ctico Integral",
      description: `Desarrollar proyecto completo aplicando todos los conceptos de ${base.title}.`,
      solution:
        "Proyecto profesional con implementaciÃ³n completa y documentaciï¿½ï¿½ï¿½ï¿½n.",
    },
  ];

  base.summary = `Dominio completo del tema ${base.title} con competencias profesionales para aplicaciÃ³n prÃ¡ctica.`;
  return base;
};

// Helper functions
const getThemeTitle = (courseId: string, themeIndex: number): string => {
  const themes: { [key: string]: string[] } = {
    "programador-desde-cero": [
      "IntroducciÃ³n a la ProgramaciÃ³n",
      "Variables y Tipos de Datos",
      "Estructuras de Control",
      "Funciones y MÃ©todos",
      "Arrays y Colecciones",
      "ProgramaciÃ³n Orientada a Objetos",
      "Bases de Datos",
      "Desarrollo Web",
      "Proyecto Final",
    ],
    "auxiliar-veterinaria": [
      "AnatomÃ­a Animal BÃ¡sica",
      "FisiologÃ­a Veterinaria",
      "TÃ©cnicas de ExploraciÃ³n",
      "Primeros Auxilios",
      "FarmacologÃ­a BÃ¡sica",
      "InstrumentaciÃ³n Veterinaria",
      "Especies Menores",
      "Especies Mayores",
      "PrÃ¡ctica Profesional",
    ],
    "peluqueria-profesional": [
      "AnatomÃ­a del Cabello",
      "TÃ©cnicas de Corte",
      "Coloraciï¿½ï¿½n Profesional",
      "Tratamientos Capilares",
      "Peinados y Recogidos",
      "TÃ©cnicas Avanzadas",
      "AtenciÃ³n al Cliente",
      "GestiÃ³n de SalÃ³n",
      "Portfolio Profesional",
    ],
    electricista: [
      "Fundamentos de Electricidad",
      "Circuitos Elï¿½ï¿½ctricos",
      "Instalaciones Residenciales",
      "Instalaciones Industriales",
      "Normativa REBT",
      "Seguridad ElÃ©ctrica",
      "AutomatizaciÃ³n",
      "Mantenimiento",
      "Proyecto Integral",
    ],
    fontaneria: [
      "Fundamentos de FontanerÃ­a",
      "Instalaciones de Agua",
      "Instalaciones de Gas",
      "CalefacciÃ³n",
      "Saneamiento",
      "Herramientas y Materiales",
      "Reparaciones",
      "Mantenimiento",
      "Proyecto Final",
    ],
  };

  return themes[courseId]?.[themeIndex] || `Tema ${themeIndex + 1}`;
};

const getThemeDescription = (courseId: string, themeIndex: number): string => {
  return `Contenido profesional del tema ${themeIndex + 1} del curso ${courseId}.`;
};

// Function to force generate and save curriculum content
export const generateAndSaveCurriculumContent = async (
  courseId: string,
  themeIndex: number,
): Promise<boolean> => {
  try {
    console.log(`ðŸš€ Generando tema ${themeIndex + 1} de ${courseId}...`);

    const content = generateDefaultContent(courseId, themeIndex);
    const success = await storeCurriculumContent(content);

    if (success) {
      console.log(
        `âœ… Tema ${themeIndex + 1} de ${courseId} guardado exitosamente en Firebase`,
      );
      console.log(
        `ðŸ“„ Contenido: ${content.sections.length} secciones, ${content.exercises.length} ejercicios`,
      );
      return true;
    } else {
      console.error(
        `âŒ Error al guardar tema ${themeIndex + 1} de ${courseId}`,
      );
      return false;
    }
  } catch (error) {
    console.error(
      `âŒ Error generando tema ${themeIndex + 1} de ${courseId}:`,
      error,
    );
    return false;
  }
};

// Create demo academia data for a specific user
const createDemoAcademiaForUser = (
  userId: string,
  userEmail: string,
): Academia[] => {
  const academiaName = `Academia Demo ${userEmail.split("@")[0]}`;
  const slug = `academia-demo-${userEmail.split("@")[0].toLowerCase()}`;

  return [
    {
      id: `demo-academia-${userId}`,
      name: academiaName,
      slug: slug,
      description: "Academia de demostraciÃ³n con cursos profesionales",
      logo: "https://images.unsplash.com/photo-1562774053-701939374585?w=400",
      banner:
        "https://images.unsplash.com/photo-1522202176988-66273c2fd55f?w=1200",
      colors: {
        primary: "#3B82F6",
        secondary: "#64748B",
        accent: "#10B981",
      },
      social: {
        website: "https://academia-demo.com",
        email: userEmail,
        phone: "+34 123 456 789",
        facebook: "https://facebook.com/academia-demo",
        instagram: "https://instagram.com/academia-demo",
        twitter: "https://twitter.com/academia-demo",
      },
      settings: {
        allowPublicCourses: true,
        requireApproval: false,
        enableCertificates: true,
        enableDiscussions: true,
        maxStudentsPerCourse: 50,
      },
      stats: {
        totalStudents: 150,
        totalCourses: 12,
        totalInstructors: 8,
        averageRating: 4.8,
      },
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      ownerId: userId,
    },
  ];
};

interface Academia {
  id: string;
  name: string;
  slug: string;
  description: string;
  logo: string;
  banner: string;
  colors: {
    primary: string;
    secondary: string;
    accent: string;
  };
  social: {
    website: string;
    email: string;
    phone: string;
    facebook: string;
    instagram: string;
    twitter: string;
  };
  settings: {
    allowPublicCourses: boolean;
    requireApproval: boolean;
    enableCertificates: boolean;
    enableDiscussions: boolean;
    maxStudentsPerCourse: number;
  };
  stats: {
    totalStudents: number;
    totalCourses: number;
    totalInstructors: number;
    averageRating: number;
  };
  createdAt: string;
  updatedAt: string;
  ownerId: string;
}

export const getAcademias = async (userId: string): Promise<Academia[]> => {
  if (!userId) return [];

  try {
    const wrapper = await getFirestoreWrapper();
    const academias = await wrapper.getCollection(
      "academias",
      where("ownerId", "==", userId),
    );

    if (academias.length === 0) {
      // Create demo academia
      const user = auth.currentUser;
      if (user?.email) {
        const demoAcademias = createDemoAcademiaForUser(userId, user.email);

        // Store demo academia
        for (const academia of demoAcademias) {
          await wrapper.setDocument("academias", academia.id, academia);
        }

        return demoAcademias;
      }
    }

    return academias as Academia[];
  } catch (error) {
    console.error("Error fetching academias:", error);

    // Return demo data if Firebase fails
    const user = auth.currentUser;
    if (user?.email) {
      return createDemoAcademiaForUser(userId, user.email);
    }

    return [];
  }
};

export const createAcademia = async (
  userId: string,
  academiaData: Partial<Academia>,
): Promise<string | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const academia = {
      ...academiaData,
      id: `academia-${Date.now()}`,
      ownerId: userId,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    const success = await wrapper.setDocument(
      "academias",
      academia.id,
      academia,
    );
    return success ? academia.id : null;
  } catch (error) {
    console.error("Error creating academia:", error);
    return null;
  }
};

export const updateAcademia = async (
  academiaId: string,
  updates: Partial<Academia>,
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const updateData = {
      ...updates,
      updatedAt: new Date().toISOString(),
    };

    return await wrapper.updateDocument("academias", academiaId, updateData);
  } catch (error) {
    console.error("Error updating academia:", error);
    return false;
  }
};

export const deleteAcademia = async (academiaId: string): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    return await wrapper.deleteDocument("academias", academiaId);
  } catch (error) {
    console.error("Error deleting academia:", error);
    return false;
  }
};

// Courses data management
export const getCourses = async (academiaId: string) => {
  if (!academiaId) return getDemoProfessionalCourses();

  try {
    const wrapper = await getFirestoreWrapper();
    const courses = await wrapper.getCollection(
      "courses",
      where("academiaId", "==", academiaId),
    );

    if (courses.length === 0) {
      // Return demo courses for the academia
      return getDemoProfessionalCourses();
    }

    return courses;
  } catch (error) {
    console.error("Error fetching courses:", error);
    return getDemoProfessionalCourses();
  }
};

export const getCourse = async (courseId: string) => {
  try {
    const wrapper = await getFirestoreWrapper();
    const course = await wrapper.getDocument("courses", courseId);

    if (!course) {
      // Return demo course if not found
      const demoCourses = getDemoProfessionalCourses();
      return demoCourses.find((c) => c.id === courseId) || null;
    }

    return course;
  } catch (error) {
    console.error("Error fetching course:", error);
    const demoCourses = getDemoProfessionalCourses();
    return demoCourses.find((c) => c.id === courseId) || null;
  }
};

export const createCourse = async (courseData: any): Promise<string | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const course = {
      ...courseData,
      id: `course-${Date.now()}`,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    const success = await wrapper.setDocument("courses", course.id, course);
    return success ? course.id : null;
  } catch (error) {
    console.error("Error creating course:", error);
    return null;
  }
};

export const updateCourse = async (
  courseId: string,
  updates: any,
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const updateData = {
      ...updates,
      updatedAt: new Date().toISOString(),
    };

    return await wrapper.updateDocument("courses", courseId, updateData);
  } catch (error) {
    console.error("Error updating course:", error);
    return false;
  }
};

export const deleteCourse = async (courseId: string): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    return await wrapper.deleteDocument("courses", courseId);
  } catch (error) {
    console.error("Error deleting course:", error);
    return false;
  }
};

// Students data management
export const getStudents = async (academiaId: string) => {
  try {
    const wrapper = await getFirestoreWrapper();
    return await wrapper.getCollection(
      "students",
      where("academiaId", "==", academiaId),
    );
  } catch (error) {
    console.error("Error fetching students:", error);
    return [];
  }
};

export const createStudent = async (
  studentData: any,
): Promise<string | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const student = {
      ...studentData,
      id: `student-${Date.now()}`,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    const success = await wrapper.setDocument("students", student.id, student);
    return success ? student.id : null;
  } catch (error) {
    console.error("Error creating student:", error);
    return null;
  }
};

export const updateStudent = async (
  studentId: string,
  updates: any,
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const updateData = {
      ...updates,
      updatedAt: new Date().toISOString(),
    };

    return await wrapper.updateDocument("students", studentId, updateData);
  } catch (error) {
    console.error("Error updating student:", error);
    return false;
  }
};

export const deleteStudent = async (studentId: string): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    return await wrapper.deleteDocument("students", studentId);
  } catch (error) {
    console.error("Error deleting student:", error);
    return false;
  }
};

// Admin functions
export const checkIsCurrentUserAdmin = async (): Promise<boolean> => {
  try {
    const user = auth.currentUser;
    if (!user) return false;

    const wrapper = await getFirestoreWrapper();
    const adminDoc = await wrapper.getDocument("admins", user.uid);

    return adminDoc !== null;
  } catch (error) {
    console.error("Error checking admin status:", error);
    return false;
  }
};

export const ensureDefaultAdminExists = async (): Promise<boolean> => {
  try {
    const user = auth.currentUser;
    if (!user) return false;

    const wrapper = await getFirestoreWrapper();

    // Check if user is already admin
    const existingAdmin = await wrapper.getDocument("admins", user.uid);
    if (existingAdmin) return true;

    // Create admin record
    const adminData = {
      uid: user.uid,
      email: user.email,
      displayName: user.displayName || "Admin",
      role: "admin",
      createdAt: new Date().toISOString(),
      permissions: ["all"],
    };

    const success = await wrapper.setDocument("admins", user.uid, adminData);
    return success;
  } catch (error) {
    console.error("Error ensuring admin exists:", error);
    return false;
  }
};

export const checkIsAdmin = async (userId: string): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const adminDoc = await wrapper.getDocument("admins", userId);
    return adminDoc !== null;
  } catch (error) {
    console.error("Error checking admin status:", error);
    return false;
  }
};

// User Management interface
export interface UserManagement {
  uid: string;
  email: string;
  displayName: string;
  role: string;
  academiaIds: string[];
  createdAt: string;
  updatedAt: string;
}

export const getUserManagement = async (
  userId: string,
): Promise<UserManagement | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const userDoc = await wrapper.getDocument("userManagement", userId);
    return userDoc as UserManagement;
  } catch (error) {
    console.error("Error getting user management:", error);
    return null;
  }
};

export const createOrUpdateUserManagementFromAuth = async (
  userId: string,
  academiaId?: string,
): Promise<UserManagement> => {
  try {
    const user = auth.currentUser;
    const wrapper = await getFirestoreWrapper();

    // Get existing user management or create new
    let userManagement = await getUserManagement(userId);

    if (!userManagement) {
      userManagement = {
        uid: userId,
        email: user?.email || "",
        displayName: user?.displayName || "Usuario",
        role: "student",
        academiaIds: academiaId ? [academiaId] : [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };
    } else {
      // Update existing
      userManagement.updatedAt = new Date().toISOString();
      if (academiaId && !userManagement.academiaIds.includes(academiaId)) {
        userManagement.academiaIds.push(academiaId);
      }
    }

    await wrapper.setDocument("userManagement", userId, userManagement);
    return userManagement;
  } catch (error) {
    console.error("Error creating/updating user management:", error);
    throw error;
  }
};

export const getUserAcademias = async (userId: string): Promise<Academia[]> => {
  try {
    const userManagement = await getUserManagement(userId);
    if (!userManagement || userManagement.academiaIds.length === 0) {
      return [];
    }

    const wrapper = await getFirestoreWrapper();
    const academias: Academia[] = [];

    for (const academiaId of userManagement.academiaIds) {
      const academia = await wrapper.getDocument("academias", academiaId);
      if (academia) {
        academias.push(academia as Academia);
      }
    }

    return academias;
  } catch (error) {
    console.error("Error getting user academias:", error);
    return [];
  }
};

export const getAllUsers = async (): Promise<any[]> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const users = await wrapper.getCollection("userManagement");
    return users;
  } catch (error) {
    console.error("Error getting all users:", error);
    return [];
  }
};

export const createUserManagement = async (
  userData: any,
): Promise<string | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const userId = `user-${Date.now()}`;

    const userManagement = {
      id: userId,
      ...userData,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    const success = await wrapper.setDocument(
      "userManagement",
      userId,
      userManagement,
    );
    return success ? userId : null;
  } catch (error) {
    console.error("Error creating user management:", error);
    return null;
  }
};

export const toggleDemoMode = async (
  userId: string,
  currentDemoMode: boolean,
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const updateData = {
      isDemoMode: !currentDemoMode,
      updatedAt: new Date().toISOString(),
    };

    return await wrapper.updateDocument("userManagement", userId, updateData);
  } catch (error) {
    console.error("Error toggling demo mode:", error);
    return false;
  }
};

export const getAllAcademias = async (): Promise<Academia[]> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const academias = await wrapper.getCollection("academias");
    return academias as Academia[];
  } catch (error) {
    console.error("Error getting all academias:", error);
    return [];
  }
};

export const createAcademiaWithAdminUser = async (
  academiaData: any,
  adminData: any,
): Promise<{ academiaId: string; success: boolean }> => {
  try {
    const wrapper = await getFirestoreWrapper();

    // Create academia
    const academiaId = `academia-${Date.now()}`;
    const academia = {
      id: academiaId,
      ...academiaData,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    const academiaSuccess = await wrapper.setDocument(
      "academias",
      academiaId,
      academia,
    );

    if (academiaSuccess) {
      // Create or update admin user
      const adminId = adminData.uid || `admin-${Date.now()}`;
      const admin = {
        ...adminData,
        academiaIds: [academiaId],
        role: "admin",
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      await wrapper.setDocument("userManagement", adminId, admin);
    }

    return { academiaId, success: academiaSuccess };
  } catch (error) {
    console.error("Error creating academia with admin:", error);
    return { academiaId: "", success: false };
  }
};

export const generateAcademiaSlug = (name: string): string => {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)/g, "");
};

// Payment and notification stubs (if needed)
export interface PaymentRecord {
  id: string;
  amount: number;
  currency: string;
  userId: string;
  status: string;
  createdAt: string;
}

export const createPaymentRecord = async (
  paymentData: any,
): Promise<string | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const paymentId = `payment-${Date.now()}`;

    const payment = {
      id: paymentId,
      ...paymentData,
      createdAt: new Date().toISOString(),
    };

    const success = await wrapper.setDocument("payments", paymentId, payment);
    return success ? paymentId : null;
  } catch (error) {
    console.error("Error creating payment record:", error);
    return null;
  }
};

export const sendPaymentEmailNotification = async (
  email: string,
  paymentData: any,
): Promise<boolean> => {
  try {
    // Email notification logic would go here
    console.log("Email notification sent to:", email, paymentData);
    return true;
  } catch (error) {
    console.error("Error sending email notification:", error);
    return false;
  }
};

export const updateUserManagement = async (
  userId: string,
  updates: any,
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const updateData = {
      ...updates,
      updatedAt: new Date().toISOString(),
    };

    return await wrapper.updateDocument("userManagement", userId, updateData);
  } catch (error) {
    console.error("Error updating user management:", error);
    return false;
  }
};

// Course-related functions
export const getAllProfessionalCourses = async (): Promise<
  ProfessionalCourse[]
> => {
  try {
    return getDemoProfessionalCourses();
  } catch (error) {
    console.error("Error getting professional courses:", error);
    return getDemoProfessionalCourses();
  }
};

export const getCourseById = async (
  courseId: string,
): Promise<ProfessionalCourse | null> => {
  try {
    const courses = getDemoProfessionalCourses();
    return courses.find((c) => c.id === courseId) || null;
  } catch (error) {
    console.error("Error getting course by ID:", error);
    return null;
  }
};

export const getDemoCourseThemes = (courseId: string): CourseTheme[] => {
  // Generate demo themes for the course
  const themes: CourseTheme[] = [];
  for (let i = 0; i < 9; i++) {
    themes.push({
      id: `${courseId}-theme-${i}`,
      courseId: courseId,
      title: `Tema ${i + 1}`,
      description: `DescripciÃ³n del tema ${i + 1}`,
      order: i,
      duration: "2-3 horas",
      content: `Contenido extenso del tema ${i + 1}`,
      objectives: [
        `Objetivo 1 del tema ${i + 1}`,
        `Objetivo 2 del tema ${i + 1}`,
      ],
      resources: [`Recurso 1`, `Recurso 2`],
    });
  }
  return themes;
};

export const getCourseThemes = async (
  courseId: string,
): Promise<CourseTheme[]> => {
  try {
    return getDemoCourseThemes(courseId);
  } catch (error) {
    console.error("Error getting course themes:", error);
    return getDemoCourseThemes(courseId);
  }
};

export const checkCourseAccess = async (
  courseId: string,
  userId: string,
): Promise<boolean> => {
  try {
    // Get current user to check email
    const currentUser = auth.currentUser;

    // If usuario2@usuario, deny access (remove subscriptions)
    if (currentUser?.email === "usuario2@usuario" || currentUser?.email === "usuario2@usuario.com") {
      console.log("ðŸš« Course access denied for usuario2 - subscriptions removed");
      return false;
    }

    // For demo purposes, give access to all other users
    return true;
  } catch (error) {
    console.error("Error checking course access:", error);
    return false;
  }
};

export const getUserCourseAccess = async (
  userId: string,
): Promise<UserCourseAccess[]> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const access = await wrapper.getCollection(
      "userCourseAccess",
      where("userId", "==", userId),
    );
    return access as UserCourseAccess[];
  } catch (error) {
    console.error("Error getting user course access:", error);
    return [];
  }
};

export const getAllUserCourseAccess = async (): Promise<UserCourseAccess[]> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const access = await wrapper.getCollection("userCourseAccess");
    return access as UserCourseAccess[];
  } catch (error) {
    console.error("Error getting all user course access:", error);
    return [];
  }
};

export const createUserCourseAccess = async (
  accessData: any,
): Promise<string | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const accessId = `access-${Date.now()}`;

    const access = {
      id: accessId,
      ...accessData,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    const success = await wrapper.setDocument(
      "userCourseAccess",
      accessId,
      access,
    );
    return success ? accessId : null;
  } catch (error) {
    console.error("Error creating user course access:", error);
    return null;
  }
};

export const getCourseProgress = async (
  userId: string,
  courseId: string,
): Promise<CourseProgress | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const progressId = `${userId}-${courseId}`;
    const progress = await wrapper.getDocument("courseProgress", progressId);
    return progress as CourseProgress;
  } catch (error) {
    console.error("Error getting course progress:", error);
    return null;
  }
};

export const updateCourseProgress = async (
  progressData: CourseProgress,
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const progressId = `${progressData.userId}-${progressData.courseId}`;

    const updateData = {
      ...progressData,
      updatedAt: new Date().toISOString(),
    };

    return await wrapper.setDocument("courseProgress", progressId, updateData);
  } catch (error) {
    console.error("Error updating course progress:", error);
    return false;
  }
};

// Assistant-related functions
export const getAssistantTemario = async (
  assistantId: string,
): Promise<AssistantTemario | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const temario = await wrapper.getDocument("assistantTemarios", assistantId);
    return temario as AssistantTemario;
  } catch (error) {
    console.error("Error getting assistant temario:", error);
    return null;
  }
};

export const getAssistantPricing = async (
  assistantId: string,
): Promise<AssistantPricing | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const pricing = await wrapper.getDocument("assistantPricing", assistantId);
    return pricing as AssistantPricing;
  } catch (error) {
    console.error("Error getting assistant pricing:", error);
    return null;
  }
};

export const checkUserHasAccess = async (
  userId: string,
  assistantId: string,
): Promise<boolean> => {
  try {
    // Get current user to check email
    const currentUser = auth.currentUser;

    // If usuario2@usuario, deny access (remove subscriptions)
    if (currentUser?.email === "usuario2@usuario" || currentUser?.email === "usuario2@usuario.com") {
      console.log("ðŸš« Access denied for usuario2 - subscriptions removed");
      return false;
    }

    // For demo purposes, give access to all other users
    return true;
  } catch (error) {
    console.error("Error checking user access:", error);
    return false;
  }
};

// Test and flashcard functions
export const saveTestResult = async (result: any): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const resultId = `test-${Date.now()}`;

    const testResult = {
      id: resultId,
      ...result,
      createdAt: new Date().toISOString(),
    };

    return await wrapper.setDocument("testResults", resultId, testResult);
  } catch (error) {
    console.error("Error saving test result:", error);
    return false;
  }
};

export const getThemeFlashcards = async (themeId: string): Promise<any[]> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const flashcards = await wrapper.getCollection(
      "flashcards",
      where("themeId", "==", themeId),
    );
    return flashcards;
  } catch (error) {
    console.error("Error getting theme flashcards:", error);
    return [];
  }
};

export const generateDemoFlashcards = (themeId: string): any[] => {
  // Generate demo flashcards for the theme
  return [
    {
      id: `${themeId}-card-1`,
      themeId: themeId,
      front: "Pregunta de ejemplo 1",
      back: "Respuesta de ejemplo 1",
      difficulty: "easy",
    },
    {
      id: `${themeId}-card-2`,
      themeId: themeId,
      front: "Pregunta de ejemplo 2",
      back: "Respuesta de ejemplo 2",
      difficulty: "medium",
    },
  ];
};

// Save tests for a theme (with option to append)
export const saveThemeTests = async (
  assistantId: string,
  themeId: string,
  newTests: any[],
  append: boolean = false
): Promise<void> => {
  try {
    const wrapper = await getFirestoreWrapper();

    if (append) {
      // Get existing tests first
      const existingTests = await wrapper.getCollection(
        "tests",
        where("assistantId", "==", assistantId),
        where("themeId", "==", themeId)
      );

      // Combine existing with new tests
      const allTests = [...existingTests, ...newTests];

      // Save combined tests
      await wrapper.setDocument("assistants", assistantId, {
        [`tests.${themeId}`]: allTests
      }, { merge: true });
    } else {
      // Replace existing tests
      await wrapper.setDocument("assistants", assistantId, {
        [`tests.${themeId}`]: newTests
      }, { merge: true });
    }
  } catch (error) {
    console.error("Error saving theme tests:", error);
    throw error;
  }
};

// Save flashcards for a theme (with option to append)
export const saveThemeFlashcards = async (
  assistantId: string,
  themeId: string,
  newFlashcards: any[],
  append: boolean = false
): Promise<void> => {
  try {
    const wrapper = await getFirestoreWrapper();

    if (append) {
      // Get existing flashcards first
      const existingFlashcards = await wrapper.getCollection(
        "flashcards",
        where("assistantId", "==", assistantId),
        where("themeId", "==", themeId)
      );

      // Combine existing with new flashcards
      const allFlashcards = [...existingFlashcards, ...newFlashcards];

      // Save combined flashcards
      await wrapper.setDocument("assistants", assistantId, {
        [`flashcards.${themeId}`]: allFlashcards
      }, { merge: true });
    } else {
      // Replace existing flashcards
      await wrapper.setDocument("assistants", assistantId, {
        [`flashcards.${themeId}`]: newFlashcards
      }, { merge: true });
    }
  } catch (error) {
    console.error("Error saving theme flashcards:", error);
    throw error;
  }
};

export const getThemeQuestions = async (
  themeId: string,
): Promise<TestQuestion[]> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const questions = await wrapper.getCollection(
      "themeQuestions",
      where("themeId", "==", themeId),
    );

    if (questions.length === 0) {
      // Generate demo questions if none exist
      return generateDemoQuestions(themeId);
    }

    return questions as TestQuestion[];
  } catch (error) {
    console.error("Error getting theme questions:", error);
    return generateDemoQuestions(themeId);
  }
};

export const generateDemoQuestions = (themeId: string): TestQuestion[] => {
  // Generate demo questions for the theme
  return [
    {
      id: `${themeId}-question-1`,
      question: "Â¿CuÃ¡l es el concepto principal de este tema?",
      options: [
        "OpciÃ³n A: Respuesta incorrecta",
        "OpciÃ³n B: Respuesta correcta",
        "Opciï¿½ï¿½n C: Otra respuesta incorrecta",
        "OpciÃ³n D: Respuesta incorrecta adicional",
      ],
      correctAnswer: 1,
      explanation:
        "La opciÃ³n B es correcta porque aborda el concepto fundamental del tema.",
      difficulty: "medium",
    },
    {
      id: `${themeId}-question-2`,
      question: "Â¿QuÃ© tÃ©cnica es mÃ¡s recomendada en este contexto?",
      options: [
        "TÃ©cnica tradicional",
        "TÃ©cnica moderna",
        "TÃ©cnica experimental",
        "TÃ©cnica combinada",
      ],
      correctAnswer: 3,
      explanation: "La tÃ©cnica combinada aprovecha lo mejor de cada enfoque.",
      difficulty: "hard",
    },
    {
      id: `${themeId}-question-3`,
      question: "Â¿CuÃ¡l es la aplicaciÃ³n prÃ¡ctica mÃ¡s comÃºn?",
      options: [
        "AplicaciÃ³n en laboratorio",
        "AplicaciÃ³n en campo",
        "AplicaciÃ³n teÃ³rica",
        "AplicaciÃ³n mixta",
      ],
      correctAnswer: 1,
      explanation:
        "La aplicaciÃ³n en campo es la mÃ¡s utilizada en la prÃ¡ctica profesional.",
      difficulty: "easy",
    },
    {
      id: `${themeId}-question-4`,
      question: "Â¿QuÃ© factor es mÃ¡s importante para el Ã©xito?",
      options: [
        "La experiencia previa",
        "El conocimiento teÃ³rico",
        "La prÃ¡ctica constante",
        "La combinaciÃ³n de todos los anteriores",
      ],
      correctAnswer: 3,
      explanation:
        "El Ã©xito requiere una combinaciÃ³n equilibrada de experiencia, teorÃ­a y prÃ¡ctica.",
      difficulty: "medium",
    },
    {
      id: `${themeId}-question-5`,
      question: "Â¿CuÃ¡l es el error mÃ¡s comÃºn que se debe evitar?",
      options: [
        "Falta de preparaciÃ³n",
        "Exceso de confianza",
        "AplicaciÃ³n incorrecta de tÃ©cnicas",
        "Todos los anteriores",
      ],
      correctAnswer: 3,
      explanation:
        "Todos estos errores son comunes y deben evitarse para garantizar el Ã©xito.",
      difficulty: "hard",
    },
  ];
};

// Firebase save functions
export const saveCourseToFirebase = async (
  courseData: any,
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    return await wrapper.setDocument("courses", courseData.id, courseData);
  } catch (error) {
    console.error("Error saving course to Firebase:", error);
    return false;
  }
};

export const initializeAssistantData = async (): Promise<boolean> => {
  try {
    console.log("ðŸŽ¯ Inicializando datos de asistentes...");

    const wrapper = await getFirestoreWrapper();

    // Create demo assistant data
    const assistants = [
      {
        id: "programador-desde-cero",
        title: "Asistente de ProgramaciÃ³n",
        description: "Especialista en programaciÃ³n desde cero",
        monthlyPrice: 29.99,
        yearlyPrice: 299.99,
        features: [
          "Temario completo de programaciÃ³n",
          "Ejercicios prÃ¡cticos",
          "Proyectos reales",
          "Soporte 24/7",
        ],
      },
      {
        id: "auxiliar-veterinaria",
        title: "Asistente Veterinario",
        description: "Especialista en auxiliar de veterinaria",
        monthlyPrice: 24.99,
        yearlyPrice: 249.99,
        features: [
          "AnatomÃ­a animal completa",
          "Casos clÃ­nicos reales",
          "Protocolos veterinarios",
          "CertificaciÃ³n profesional",
        ],
      },
    ];

    // Save assistant pricing data
    for (const assistant of assistants) {
      const pricingData = {
        id: assistant.id,
        monthlyPrice: assistant.monthlyPrice,
        yearlyPrice: assistant.yearlyPrice,
        features: assistant.features,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      await wrapper.setDocument("assistantPricing", assistant.id, pricingData);

      // Create demo temario data
      const temarioData = {
        id: assistant.id,
        title: assistant.title,
        description: assistant.description,
        topics: [
          {
            id: `${assistant.id}-topic-1`,
            title: "IntroducciÃ³n",
            content: "Contenido introductorio del curso",
            order: 1,
            duration: "30 min",
          },
          {
            id: `${assistant.id}-topic-2`,
            title: "Conceptos BÃ¡sicos",
            content: "Fundamentos esenciales",
            order: 2,
            duration: "45 min",
          },
        ],
        duration: "8-10 horas",
        level: "Principiante a Intermedio",
      };

      await wrapper.setDocument("assistantTemarios", assistant.id, temarioData);
    }

    console.log("âœ… Datos de asistentes inicializados correctamente");
    return true;
  } catch (error) {
    console.error("âŒ Error inicializando datos de asistentes:", error);
    return false;
  }
};

export const setAssistantTemario = async (
  temarioData: AssistantTemario,
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const updateData = {
      ...temarioData,
      updatedAt: new Date().toISOString(),
    };

    return await wrapper.setDocument(
      "assistantTemarios",
      temarioData.id,
      updateData,
    );
  } catch (error) {
    console.error("Error setting assistant temario:", error);
    return false;
  }
};

// Global Founder Limits functions
export const getGlobalFounderLimits =
  async (): Promise<GlobalFounderLimits | null> => {
    try {
      const wrapper = await getFirestoreWrapper();
      const limits = await wrapper.getDocument("config", "globalFounderLimits");
      return limits as GlobalFounderLimits;
    } catch (error) {
      console.error("Error getting global founder limits:", error);
      return null;
    }
  };

export const setGlobalFounderLimits = async (
  limits: GlobalFounderLimits,
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const updateData = {
      ...limits,
      updatedAt: new Date().toISOString(),
    };

    return await wrapper.setDocument(
      "config",
      "globalFounderLimits",
      updateData,
    );
  } catch (error) {
    console.error("Error setting global founder limits:", error);
    return false;
  }
};

// Academia Teacher functions
export const addTeacherToAcademia = async (
  academiaId: string,
  teacherData: Partial<AcademiaTeacher>,
): Promise<string | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const teacherId = `teacher-${Date.now()}`;

    const teacher: AcademiaTeacher = {
      id: teacherId,
      academiaId: academiaId,
      name: teacherData.name || "",
      email: teacherData.email || "",
      phone: teacherData.phone,
      specialties: teacherData.specialties || [],
      assignedCourses: teacherData.assignedCourses || [],
      bio: teacherData.bio,
      qualifications: teacherData.qualifications || [],
      status: "active",
      joinDate: new Date().toISOString(),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    const success = await wrapper.setDocument(
      "academiaTeachers",
      teacherId,
      teacher,
    );
    return success ? teacherId : null;
  } catch (error) {
    console.error("Error adding teacher to academia:", error);
    return null;
  }
};

export const removeTeacherFromAcademia = async (
  academiaId: string,
  teacherId: string,
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    return await wrapper.deleteDocument("academiaTeachers", teacherId);
  } catch (error) {
    console.error("Error removing teacher from academia:", error);
    return false;
  }
};

export const getAcademiaTeachers = async (
  academiaId: string,
): Promise<AcademiaTeacher[]> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const teachers = await wrapper.getCollection(
      "academiaTeachers",
      where("academiaId", "==", academiaId),
    );
    return teachers as AcademiaTeacher[];
  } catch (error) {
    console.error("Error getting academia teachers:", error);
    return [];
  }
};

// Academia Student functions (enhanced)
export const createAcademiaStudent = async (
  studentData: Partial<AcademiaStudent>,
): Promise<string | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const studentId = `student-${Date.now()}`;

    const student: AcademiaStudent = {
      id: studentId,
      academiaId: studentData.academiaId || "",
      name: studentData.name || "",
      email: studentData.email || "",
      phone: studentData.phone,
      enrolledCourses: studentData.enrolledCourses || [],
      progress: studentData.progress || {},
      status: "active",
      enrollmentDate: new Date().toISOString(),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    const success = await wrapper.setDocument(
      "academiaStudents",
      studentId,
      student,
    );
    return success ? studentId : null;
  } catch (error) {
    console.error("Error creating academia student:", error);
    return null;
  }
};

export const updateAcademiaStudent = async (
  studentId: string,
  updates: Partial<AcademiaStudent>,
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const updateData = {
      ...updates,
      updatedAt: new Date().toISOString(),
    };

    return await wrapper.updateDocument(
      "academiaStudents",
      studentId,
      updateData,
    );
  } catch (error) {
    console.error("Error updating academia student:", error);
    return false;
  }
};

export const deleteAcademiaStudent = async (
  studentId: string,
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    return await wrapper.deleteDocument("academiaStudents", studentId);
  } catch (error) {
    console.error("Error deleting academia student:", error);
    return false;
  }
};

export const getAcademiaStudent = async (
  studentId: string,
): Promise<AcademiaStudent | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const student = await wrapper.getDocument("academiaStudents", studentId);
    return student as AcademiaStudent;
  } catch (error) {
    console.error("Error getting academia student:", error);
    return null;
  }
};

// Update the existing getAcademiaStudents to return proper type
export const getAcademiaStudents = async (
  academiaId: string,
): Promise<AcademiaStudent[]> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const students = await wrapper.getCollection(
      "academiaStudents",
      where("academiaId", "==", academiaId),
    );
    return students as AcademiaStudent[];
  } catch (error) {
    console.error("Error getting academia students:", error);
    return [];
  }
};

// Academia functions (additional)
export const getAcademia = async (
  academiaId: string,
): Promise<Academia | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const academia = await wrapper.getDocument("academias", academiaId);
    return academia as Academia;
  } catch (error) {
    console.error("Error getting academia:", error);
    return null;
  }
};

export const getAcademiaBySlug = async (
  slug: string,
): Promise<Academia | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const academias = await wrapper.getCollection(
      "academias",
      where("slug", "==", slug),
    );
    return academias.length > 0 ? (academias[0] as Academia) : null;
  } catch (error) {
    console.error("Error getting academia by slug:", error);
    return null;
  }
};

// ========================================
// CURRICULUM THEME MANAGEMENT FUNCTIONS
// ========================================

// Upload PDF file to Firebase Storage
export const uploadPDFFile = async (
  file: File,
  assistantId: string,
  themeNumber: number,
): Promise<{ url: string; fileName: string; size: number } | null> => {
  try {
    const storage = getFirebaseStorage();
    if (!storage) {
      throw new Error("Firebase Storage not initialized");
    }

    // Create a reference with a unique filename
    const timestamp = Date.now();
    const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.-]/g, "_");
    const fileName = `curriculum/${assistantId}/theme-${themeNumber}-${timestamp}-${sanitizedFileName}`;
    const storageRef = ref(storage, fileName);

    // Upload the file
    const snapshot = await uploadBytes(storageRef, file);

    // Get the download URL
    const downloadURL = await getDownloadURL(snapshot.ref);

    return {
      url: downloadURL,
      fileName: sanitizedFileName,
      size: file.size,
    };
  } catch (error) {
    console.error("Error uploading PDF file:", error);
    return null;
  }
};

// Delete PDF file from Firebase Storage
export const deletePDFFile = async (pdfUrl: string): Promise<boolean> => {
  try {
    const storage = getFirebaseStorage();
    if (!storage) {
      throw new Error("Firebase Storage not initialized");
    }

    const fileRef = ref(storage, pdfUrl);
    await deleteObject(fileRef);
    return true;
  } catch (error) {
    console.error("Error deleting PDF file:", error);
    return false;
  }
};

// Get all curriculum themes for an assistant
export const getCurriculumThemes = async (
  assistantId: string,
): Promise<CurriculumTheme[]> => {
  try {
    const wrapper = await getFirestoreWrapper();

    // First, try the user's preferred path: /assistants/{assistantId}/temario
    console.log(`ðŸ” Checking user's preferred path: assistants/${assistantId}/temario`);
    try {
      const themesCollection = await wrapper.getCollection(`assistants/${assistantId}/temario`);

      if (themesCollection && themesCollection.length > 0) {
        console.log(`ðŸ“š Found ${themesCollection.length} themes in preferred path for ${assistantId}`);

        // Convert from user's format to CurriculumTheme format
        const convertedThemes: CurriculumTheme[] = themesCollection.map((doc: any) => ({
          id: doc.id,
          assistantId: assistantId,
          number: doc.numero || 1,
          title: doc.titulo || doc.title || "TÃ­tulo del tema",
          description: doc.descripcion || doc.description || "DescripciÃ³n del tema",
          content: doc.contenido || doc.content || "",
          pdfUrl: doc.pdfUrl || null,
          pdfFileName: doc.pdfFileName || null,
          pdfSize: doc.pdfSize || null,
          order: doc.orden || doc.order || doc.numero || 1,
          isActive: doc.activo !== undefined ? doc.activo : (doc.isActive !== undefined ? doc.isActive : true),
          createdAt: doc.fechaCreacion || doc.createdAt || new Date().toISOString(),
          updatedAt: doc.fechaActualizacion || doc.updatedAt || new Date().toISOString(),
        }));

        return convertedThemes.sort((a, b) => a.order - b.order);
      }
    } catch (preferredPathError) {
      console.log(`âš ï¸ No themes in preferred path, trying fallback...`);
    }

    // Fallback to original location
    // Avoid composite index requirement by querying only with where() and sorting client-side
    const themes = await wrapper.getCollection(
      "curriculumThemes",
      where("assistantId", "==", assistantId)
    );

    if (themes && themes.length > 0) {
      console.log(`ðŸ“š Found ${themes.length} themes in fallback location for ${assistantId}`);
      // Ensure numeric 'order' and sort client-side
      const parsed = (themes as any[]).map(t => ({
        ...t,
        order: typeof t.order === 'number' ? t.order : Number(t.order) || 0,
      }));
      return parsed.sort((a, b) => a.order - b.order) as CurriculumTheme[];
    }

    console.log(`âŒ No themes found for ${assistantId} in any location`);
    return [];

  } catch (error) {
    console.error("Error getting curriculum themes:", error);
    return [];
  }
};

// Create a new curriculum theme
export const createCurriculumTheme = async (
  themeData: Omit<CurriculumTheme, "id" | "createdAt" | "updatedAt">,
): Promise<string | null> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const themeId = `tema-${themeData.number}`;

    const theme: CurriculumTheme = {
      ...themeData,
      id: themeId,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    // Save in both locations for compatibility
    // 1. Original location for theme listing
    const success1 = await wrapper.setDocument(
      "curriculumThemes",
      `${themeData.assistantId}-${themeId}`,
      theme,
    );

    // 2. User's requested structure: /assistants/{asistenteId}/temario/{temaId}/contenido
    const success2 = await wrapper.setDocument(
      `assistants/${themeData.assistantId}/temario`,
      themeId,
      {
        contenido: theme.content || "",
        titulo: theme.title,
        descripcion: theme.description,
        numero: theme.number,
        orden: theme.order,
        activo: theme.isActive,
        fechaCreacion: theme.createdAt,
        fechaActualizacion: theme.updatedAt,
        pdfUrl: theme.pdfUrl || null,
        pdfFileName: theme.pdfFileName || null,
        pdfSize: theme.pdfSize || null,
      },
    );

    console.log(`ðŸ’¾ Saved theme ${themeId} to both locations:`, { success1, success2 });
    return (success1 && success2) ? themeId : null;
  } catch (error) {
    console.error("Error creating curriculum theme:", error);
    return null;
  }
};

// Update a curriculum theme
export const updateCurriculumTheme = async (
  themeId: string,
  updates: Partial<CurriculumTheme>,
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();
    const updateData = {
      ...updates,
      updatedAt: new Date().toISOString(),
    };

    return await wrapper.updateDocument(
      "curriculumThemes",
      themeId,
      updateData,
    );
  } catch (error) {
    console.error("Error updating curriculum theme:", error);
    return false;
  }
};

// Delete a curriculum theme (and its PDF file)
export const deleteCurriculumTheme = async (
  themeId: string,
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();

    // Get the theme first to access the PDF URL
    const theme = (await wrapper.getDocument(
      "curriculumThemes",
      themeId,
    )) as CurriculumTheme;

    if (theme?.pdfUrl) {
      // Delete the PDF file from storage
      await deletePDFFile(theme.pdfUrl);
    }

    // Delete the theme document
    return await wrapper.deleteDocument("curriculumThemes", themeId);
  } catch (error) {
    console.error("Error deleting curriculum theme:", error);
    return false;
  }
};

// Reorder curriculum themes
export const reorderCurriculumThemes = async (
  assistantId: string,
  themeIds: string[],
): Promise<boolean> => {
  try {
    const wrapper = await getFirestoreWrapper();

    // Update the order of each theme
    const updatePromises = themeIds.map((themeId, index) =>
      wrapper.updateDocument("curriculumThemes", themeId, {
        order: index,
        updatedAt: new Date().toISOString(),
      }),
    );

    const results = await Promise.all(updatePromises);
    return results.every((result) => result === true);
  } catch (error) {
    console.error("Error reordering curriculum themes:", error);
    return false;
  }
};

// Upload and create theme in one operation
export const uploadThemeWithPDF = async (
  assistantId: string,
  themeData: {
    number: number;
    title: string;
    description: string;
    order: number;
  },
  pdfFile: File,
): Promise<string | null> => {
  try {
    // Upload the PDF file first
    const uploadResult = await uploadPDFFile(
      pdfFile,
      assistantId,
      themeData.number,
    );

    if (!uploadResult) {
      throw new Error("Failed to upload PDF file");
    }

    // Create the theme with PDF information
    const themeId = await createCurriculumTheme({
      assistantId,
      number: themeData.number,
      title: themeData.title,
      description: themeData.description,
      order: themeData.order,
      pdfUrl: uploadResult.url,
      pdfFileName: uploadResult.fileName,
      pdfSize: uploadResult.size,
      isActive: true,
    });

    return themeId;
  } catch (error) {
    console.error("Error uploading theme with PDF:", error);
    return null;
  }
};
